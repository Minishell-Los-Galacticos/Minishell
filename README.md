# Minishell
Minishell - Bash

ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ
ğŸ                                    RESULT                                    ğŸ
ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ
             TOTAL TEST COUNT: 881  TESTS PASSED: 726  LEAKING: 0
                     STD_OUT: 87  STD_ERR: 67  EXIT_CODE: 53
                         TOTAL FAILED AND PASSED CASES:
                                     âŒ 207
                                     âœ… 2436

## POR HACER:

## MIKEL:
- Important:
- Actualizar ultimo comando env
- env + argumento
- funcion que revierta los cambios de redirecciones porque en builtin
suceden en el padre y no en el hijo
- Test 137: âœ…âš ï¸  ./missing.out
mini error = ( command not found)
bash error = ( No such file or directory)

- Secondary:
- Bash te abra lÃ­nea para que completes el comando ver â†’ Modificar balance de ' " ( || && |
  - https://github.com/rogerdevworld/minishell/blob/main/src/bonus/loop_processing.c
  - https://github.com/rogerdevworld/minishell/blob/main/src/bonus/syntax/ft_lexer_2.c#L93


## DAVID:
- Important:
- get_arg_types funciona y sin leaks
- get_temp_asig funciona y sin leaks -> con export y con cualquier otro comando
- bugs de tempasignations bien catalogadas
- Expandir ~
- Expandir el Heredoc
- revisar caso 'ex'port A=1 --> args_type

- Secondary:
- Hacer built-in CD
- `echo $a && a=1`
- invalid read `echo $SHLVL`
- invalid read `token: =1`
- invalid read y no asignacion correcta `export A=" Hola como estas = BIEN"`
- Explota en `export A=1 =`
- Memory leak `export A+=" como estas"`
- Expansion ha de soportar los wildcards *
- Norminette
- Comentarios
- (v=1) var=2 bash: syntax error near unexpected token `var=2'

## Errores:
- En is_double_quote -> no se pueden hacer dos expansiones seguidas cuando hay `\` antes del `$` funciona para expansiones
  individuales pero la flag seteada evita las demas expansiones

Entonces, Â¿cuÃ¡l es la regla?
ParÃ©ntesis crean un subshell, y todo lo que estÃ¡ fuera de Ã©l (despuÃ©s del redireccionamiento) se trata como comandos independientes.

Sin parÃ©ntesis, todo se analiza como parte del mismo comando, y los argumentos se agrupan hasta que aparece una redirecciÃ³n o un operador lÃ³gico (&&, ||, ;).

## ARQUITECTURA GENERAL

```
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚         MAIN LOOP         â”‚
                â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
                â”‚  signals()  // PADRE      â”‚
                â”‚  init(&data)              â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚  prompt(&input)     â”‚
                   â”‚  (espera comando)   â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 (SIGINT)    â”‚   [EOF/exit]
                  PADRE      â”‚   clean & exit
                  limpia     â”‚
                  prompt     â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚ 1) TOKENIZER                 â”‚
               â”‚ - Divide en tokens           â”‚
               â”‚ - Identifica pipes, redirs   â”‚
               â”‚ - Maneja quotes              â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚ 2) EXPANSION                 â”‚
               â”‚ - Sustituye $VAR, $?         â”‚
               â”‚ - Expande wildcards          â”‚
               â”‚ - Respeta quotes             â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚ 3) AST BUILDER              â”‚
               â”‚ - Construye Ã¡rbol sintÃ¡cticoâ”‚
               â”‚ - Agrupa comandos/args      â”‚
               â”‚ - Ordena pipes/redirs       â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚ 4) EXECUTOR                 â”‚
               â”‚ - Recorre AST               â”‚
               â”‚ - fork() para comandos      â”‚
               â”‚ - Redirecciones             â”‚
               â”‚ - Pipes                     â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â–¼                           â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ PADRE               â”‚     â”‚ HIJO                â”‚
      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
      â”‚ - Espera con        â”‚     â”‚ - Restaura seÃ±ales  â”‚
      â”‚   waitpid()         â”‚     â”‚   SIG_DFL           â”‚
      â”‚ - Maneja seÃ±ales    â”‚     â”‚ - Ejecuta comando   â”‚
      â”‚   (Ctrl+C)          â”‚     â”‚ - Si seÃ±al â†’ muere  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚                           â”‚
                 â”‚       (exit/seÃ±al)        â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â–¼
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚ clean_data(data)            â”‚
                â”‚ Vuelve al MAIN LOOP         â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## OPCIÃ“N PARA FLUJO DE TRABAJO:

1. Si hay token de expansiÃ³n â†’ Se intenta expandir. Si no se puede, no importa, se ignora y no se intercambia por "".
2. Entonces se aplica una funciÃ³n de juntar (esto en caso de que haya algÃºn NO SPACE token, si no hay este token, no se junta nada).
3. Armamos el Ã¡rbol
4. Antes de ejecutar si hay token de expansiÃ³n â†’ Se intenta expandir (Ahora sÃ­ de verdad, con "" y todo el rollo) y juntar obligatoriamente (si hay algo que juntar).
5. Ejecutamos
